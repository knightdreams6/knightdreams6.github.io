import{_ as e,o as s,c as t,b as o}from"./app-738c8638.js";const n={},r=o('<p>转自：https://blog.csdn.net/luanlouis/article/details/41280959</p><h5 id="_1、什么是一级缓存-为什么使用一级缓存" tabindex="-1"><a class="header-anchor" href="#_1、什么是一级缓存-为什么使用一级缓存" aria-hidden="true">#</a> 1、什么是一级缓存？为什么使用一级缓存？</h5><blockquote><p>每当我们使用<em><strong>MyBatis</strong></em>开启一次和数据库的会话，<em><strong>MyBatis</strong></em>会创建出<strong>一个<em>SqlSession</em>对象表示一次数据库会话</strong>。</p><p>在对数据库的一次会话中，我们有可能会反复地执行完全相同的查询语句，如果不采取一些措施的话，每一次查询都会查询一次数据库,而我们在极短的时间内做了完全相同的查询，那么它们的结果极有可能完全相同，由于查询一次数据库的代价很大，这有可能造成很大的资源浪费。</p><p>为了解决这一问题，减少资源的浪费，<em><strong>MyBatis</strong></em><strong>会在表示会话的SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。</strong></p><p><strong>MyBatis会在一次会话的标识----一个SqlSession对象中创建一个本地缓存(local cache)，对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。</strong></p><p><strong>对于会话（Session）级别的数据缓存，我们称之为一级数据缓存，简称一级缓存。</strong></p></blockquote><h5 id="_2、mybatis中的一级缓存是怎样组织的-即sqlsession中的缓存是怎样组织的" tabindex="-1"><a class="header-anchor" href="#_2、mybatis中的一级缓存是怎样组织的-即sqlsession中的缓存是怎样组织的" aria-hidden="true">#</a> 2、Mybatis中的一级缓存是怎样组织的？（即SqlSession中的缓存是怎样组织的？）</h5><blockquote><p>由于<em><strong>MyBatis</strong></em>使用<em><strong>SqlSession</strong></em>对象表示一次数据库的会话，那么，对于会话级别的一级缓存也应该是在SqlSession中控制的。</p><p>实际上, <em><strong>SqlSession</strong></em>只是一个<em><strong>MyBatis</strong></em>对外的接口，<em><strong>SqlSession</strong></em>将它的工作交给了<em><strong>Executor</strong></em>执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个<em><strong>SqlSession</strong></em>对象时，<em><strong>MyBatis</strong></em>会为这个<em><strong>SqlSession</strong></em>对象创建一个新的<em><strong>Executor</strong></em>执行器，而缓存信息就被维护在这个<em><strong>Executor</strong></em>执行器中，<em><strong>MyBatis</strong></em>将缓存和对缓存相关的操作封装成了Cache接口中。<em><strong>SqlSession</strong></em>、<em><strong>Executor</strong></em>、<em><strong>Cache</strong></em>之间的关系如下列类图所示：</p></blockquote><p><img src="https://img-blog.csdn.net/20141120100824184" alt="img"></p><blockquote><p>如上述的类图所示，<em><strong>Executor</strong></em>接口的实现类<em><strong>BaseExecutor</strong></em>中拥有一个<em><strong>Cache</strong></em>接口的实现类<em><strong>PerpetualCache</strong></em>，则对于<em><strong>BaseExecutor</strong></em>对象而言，它将使用<em><strong>PerpetualCache</strong></em>对象维护缓存。</p><p><strong>PerpetualCache</strong>实现原理其实很简单，其内部就是通过一个简单的<em><strong>HashMap&lt;k,v&gt;</strong></em> 来实现的，没有其他的任何限制</p></blockquote><h5 id="_3、一级缓存的生命周期有多长" tabindex="-1"><a class="header-anchor" href="#_3、一级缓存的生命周期有多长" aria-hidden="true">#</a> 3、一级缓存的生命周期有多长？</h5><blockquote><p><strong>a. <em>MyBatis</em></strong>在开启一个数据库会话时，会 创建一个新的<em><strong>SqlSession</strong></em>对象，<em><strong>SqlSession</strong></em>对象中会有一个新的<em><strong>Executor</strong></em>对象，<em><strong>Executor</strong></em>对象中持有一个新的<strong>PerpetualCache</strong>对象；当会话结束时，<em><strong>SqlSession</strong></em>对象及其内部的<em><strong>Executor</strong></em>对象还有<strong>PerpetualCache</strong>对象也一并释放掉。</p><p><strong>b.</strong> 如果<em><strong>SqlSession</strong></em>调用了**<em>close()<em><strong>方法，会释放掉一级缓存</strong>PerpetualCache</em></em>对象，一级缓存将不可用；</p><p><strong>c.</strong> 如果<em><strong>SqlSession</strong></em>调用了<em><strong>clearCache()</strong></em>，会清空<strong>PerpetualCache</strong>对象中的数据，但是该对象仍可使用；</p><p><strong>d.</strong> <strong>SqlSession</strong>中执行了任何一个<strong>update</strong>操作(<strong>update()、delete()、insert()</strong>) ，都会清空<strong>PerpetualCache</strong>对象的数据，但是该对象可以继续使用；</p></blockquote><h5 id="_4、sqlsession-一级缓存的工作流程" tabindex="-1"><a class="header-anchor" href="#_4、sqlsession-一级缓存的工作流程" aria-hidden="true">#</a> 4、SqlSession 一级缓存的工作流程</h5><blockquote><ol><li>对于某个查询，根据****statementId,params,rowBounds*<em><strong>来构建一个</strong>key</em><em>值，根据这个</em><em>key</em><em>值去缓存</em>***Cache*<em><strong>中取出对应的</strong>key</em>*值存储的缓存结果；</li><li>判断从****Cache*<em><strong>中根据特定的</strong>key</em>*值取的数据数据是否为空，即是否命中；</li><li>如果命中，则直接将缓存结果返回；</li><li>如果没命中： <ol><li>去数据库中查询数据，得到查询结果；</li><li>将key和查询到的结果分别作为<strong>key</strong>,<strong>value</strong>对存储到****Cache****中；</li><li>将查询结果返回；</li></ol></li></ol></blockquote><h5 id="_5、-cache接口的设计以及cachekey的定义-非常重要" tabindex="-1"><a class="header-anchor" href="#_5、-cache接口的设计以及cachekey的定义-非常重要" aria-hidden="true">#</a> 5、 Cache接口的设计以及CacheKey的定义（非常重要）</h5><blockquote><p>如下图所示，<strong>MyBatis</strong>定义了一个<em><strong>org.apache.ibatis.cache.Cache</strong></em>接口作为其<em><strong>Cache</strong></em>提供者的<strong>SPI(Service Provider Interface)</strong> ，所有的<strong>MyBatis</strong>内部的<em><strong>Cache</strong></em>缓存，都应该实现这一接口。<strong>MyBatis</strong>定义了一个<strong>PerpetualCache</strong>实现类实现了<strong>Cache</strong>接口，。</p><p><strong>MyBatis</strong>内部还有很多<strong>Cache</strong>接口的实现，一级缓存只会涉及到这一个<strong>PerpetualCache</strong>子类，<strong>Cache</strong>的其他实现将会放到二级缓存中<img src="https://img-blog.csdn.net/20141120134402285" alt="img"></p></blockquote><blockquote><p>我们知道，<strong>Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中</strong>。</p><p><strong>怎么来判断某两次查询时完全相同的查询？</strong></p><p>Mybatis认为，对于两次查询，如果以下条件都完全一样，那就认为是完全相同的两次查询：</p><ol><li><strong>传入的 statementId</strong></li><li><strong>查询时要求的结果集中的结果范围（结果范围通过 <code>rowBounds.offset</code>和<code>rowBounds.limit</code>表示）</strong>。</li><li>这次查询所产生的最终要传递给<code>JDBC java.sql.PreparedStatement</code>的sql语句字符串 <code>boundSql.getSql()</code></li><li>传递给 <code>java.sql.Statement</code> 要设置的参数值</li></ol><p>现在分别解释上述四个条件：</p><ol><li><p>传入的<strong>statementId</strong>，对于<strong>MyBatis</strong>而言，你要使用它，必须需要一个<strong>statementId</strong>，它代表着你将执行什么样的<strong>Sql</strong>；</p></li><li><p><strong>MyBatis</strong>自身提供的分页功能是通过****RowBounds*<em><strong>来实现的，它通过</strong>rowBounds.offset</em><em>和</em><em>rowBounds.limit</em>*来过滤查询出来的结果集，这种分页功能是基于查询结果的再过滤，而不是进行数据库的物理分页；</p></li></ol><p>由于<strong>MyBatis</strong>底层还是依赖于****JDBC*<em><strong>实现的，那么，对于两次完全一模一样的查询，<strong>MyBatis</strong>要保证对于底层</strong></em>*JDBC*<em><strong>而言，也是完全一致的查询才行。而对于</strong></em>*JDBC*<em><strong>而言，两次查询，只要传入给</strong></em>*JDBC*<em><strong>的</strong></em>*SQL****语句完全一致，传入的参数也完全一致，就认为是两次查询是完全一致的。</p><p>3、4两条MyBatis最本质的要求就是：</p><p>​ <strong>调用JDBC的时候，传入的SQL语句要完全相同，传递给JDBC的参数值也要完全相同。</strong></p><p>综上所述,CacheKey由以下条件决定：</p><p>​ <strong>statementId + rowBounds + 传递给JDBC的SQL + 传递给JDBC的参数值</strong></p></blockquote><h5 id="一级缓存的性能分析" tabindex="-1"><a class="header-anchor" href="#一级缓存的性能分析" aria-hidden="true">#</a> 一级缓存的性能分析</h5><h6 id="_1、mybatis对会话-session-级别的一级缓存设计比较简单-就简单地使用了hashmap进行维护-并没有对hashmap的容量和大小进行限制。" tabindex="-1"><a class="header-anchor" href="#_1、mybatis对会话-session-级别的一级缓存设计比较简单-就简单地使用了hashmap进行维护-并没有对hashmap的容量和大小进行限制。" aria-hidden="true">#</a> 1、Mybatis对会话（Session）级别的一级缓存设计比较简单，就简单地使用了HashMap进行维护，并没有对HashMap的容量和大小进行限制。</h6><blockquote><p>如果我一直使用某一个****SqlSession*<em><strong>对象查询数据，这样会不会导致</strong>HashMap</em><em>太大，而导致 java.lang.OutOfMemoryError错误啊？ 这么考虑也不无道理，不过</em><strong>MyBatis</strong>*的确是这样设计的。</p><p>*<em><em>*</em>*MyBatis**</em>***这样设计也有它自己的理由：</p><p>a. 一般而言****SqlSession*<em><strong>的生存时间很短。一般情况下使用一个</strong></em>*SqlSession****对象执行的操作不会太多，执行完就会消亡；</p><p>b. 对于某一个****SqlSession*<em><strong>对象而言，只要执行</strong></em>*update*<em><strong>操作（</strong></em>*update、insert、delete*<em><strong>），都会将这个</strong></em>*SqlSession****对象中对应的一级缓存清空掉，所以一般情况下不会出现缓存过大，影响JVM内存空间的问题；</p><p>c. 可以手动地释放掉****SqlSession****对象中的缓存。</p></blockquote><h6 id="_2、一级缓存是一个粗粒度的缓存-没有更新缓存和缓存过期的概念" tabindex="-1"><a class="header-anchor" href="#_2、一级缓存是一个粗粒度的缓存-没有更新缓存和缓存过期的概念" aria-hidden="true">#</a> 2、一级缓存是一个粗粒度的缓存，没有更新缓存和缓存过期的概念</h6><blockquote><p><strong>MyBatis</strong>的一级缓存就是使用了简单的<strong>HashMap</strong>，<strong>MyBatis</strong>只负责将查询数据库的结果存储到缓存中去， 不会去判断缓存存放的时间是否过长、是否过期，因此也就没有对缓存的结果进行更新这一说了。</p></blockquote><p>根据一级缓存的特性，在使用的过程中，我认为应该注意：</p><p>1、对于数据变化频率很大，并且需要高时效准确性的数据要求，我们使用****SqlSession*<em><strong>查询的时候，要控制好</strong></em>*SqlSession*<em><strong>的生存时间，</strong></em>*SqlSession*<em><strong>的生存时间越长，它其中缓存的数据有可能就越旧，从而造成和真实数据库的误差；同时对于这种情况，用户也可以手动地适时清空</strong></em>*SqlSession****中的缓存；</p><p>2、对于只执行、并且频繁执行大范围的****select*<em><strong>操作的</strong></em>*SqlSession*<em><strong>对象，</strong></em>*SqlSession****对象的生存时间不应过长。</p>',22),g=[r];function a(m,i){return s(),t("div",null,g)}const c=e(n,[["render",a],["__file","Mybatisyijihuancun.html.vue"]]);export{c as default};
