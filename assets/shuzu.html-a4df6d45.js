import{_ as e,o as a,c as o,a as d}from"./app-830c5607.js";const r={},c=d('<h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h3><h5 id="_1-数组是一种效率最高的存储和随机访问对象引用序列的方式-这种高效是通过固定长度换来的-【数组是简单的线性序列】" tabindex="-1"><a class="header-anchor" href="#_1-数组是一种效率最高的存储和随机访问对象引用序列的方式-这种高效是通过固定长度换来的-【数组是简单的线性序列】" aria-hidden="true">#</a> 1.数组是一种效率最高的存储和随机访问对象引用序列的方式，(这种高效是通过固定长度换来的)【数组是简单的线性序列】</h5><h5 id="_2-数组可以持有基本类型-而泛型之前的容器不行-但有了泛型-容器可以指定并检查它们所持有的对象类型【看起来可以持有基本类型】。对象数组保存的是引用-基本类型数组直接保存基本类型的值" tabindex="-1"><a class="header-anchor" href="#_2-数组可以持有基本类型-而泛型之前的容器不行-但有了泛型-容器可以指定并检查它们所持有的对象类型【看起来可以持有基本类型】。对象数组保存的是引用-基本类型数组直接保存基本类型的值" aria-hidden="true">#</a> 2.数组可以持有基本类型，而泛型之前的容器不行，但有了泛型，容器可以指定并检查它们所持有的对象类型【看起来可以持有基本类型】。对象数组保存的是引用，基本类型数组直接保存基本类型的值</h5><h5 id="_3-无论使用哪种类型的数组-数组标识符只是一个引用-指向在堆中建立一个真实的对象-这个-数组-对象用以保存其他对象的引用。只读成员length是该对象的一部分-唯一一个可以访问的字段或方法" tabindex="-1"><a class="header-anchor" href="#_3-无论使用哪种类型的数组-数组标识符只是一个引用-指向在堆中建立一个真实的对象-这个-数组-对象用以保存其他对象的引用。只读成员length是该对象的一部分-唯一一个可以访问的字段或方法" aria-hidden="true">#</a> 3.无论使用哪种类型的数组，数组标识符只是一个引用，指向在堆中建立一个真实的对象，这个(数组)对象用以保存其他对象的引用。只读成员length是该对象的一部分(唯一一个可以访问的字段或方法)</h5><h5 id="_4-length是数组的大小-而不是实际保存的元素个数-新生成一个数组对象-其中所有的引用会被自动初始化为null-基本类型自动初始化为0-字符类型自动初始化为char-o-boolean类型自动初始化为false" tabindex="-1"><a class="header-anchor" href="#_4-length是数组的大小-而不是实际保存的元素个数-新生成一个数组对象-其中所有的引用会被自动初始化为null-基本类型自动初始化为0-字符类型自动初始化为char-o-boolean类型自动初始化为false" aria-hidden="true">#</a> 4. length是数组的大小，而不是实际保存的元素个数，新生成一个数组对象，其中所有的引用会被自动初始化为null，基本类型自动初始化为0，字符类型自动初始化为char(O)，boolean类型自动初始化为false</h5><h5 id="_5-工具类arrays方法" tabindex="-1"><a class="header-anchor" href="#_5-工具类arrays方法" aria-hidden="true">#</a> 5.工具类Arrays方法</h5><blockquote><p><code>equals() </code> <code>deepEquals()</code>用于比较多维数组</p><p><code>fill()</code> 填充数组 <code>binarySearch()</code> 对已排序数组进行查询</p><p><code>toString()</code> <code>hashCode()</code> <code>asList()</code>将数组转化为List</p></blockquote><h5 id="_6-数组的复制" tabindex="-1"><a class="header-anchor" href="#_6-数组的复制" aria-hidden="true">#</a> 6.数组的复制</h5><p><code>system.arraycopy()</code> 该方法比for循环复制快很多</p><p>所需参数(源数组，源数组从什么位置开始，目标数组，从目标数组什么位置开始复制，需要复制的元素个数)</p><ul><li>复制对象时只复制了对象的引用“浅拷贝”</li><li>不会自动执行自动包装和拆包，两个对对象必须有相同的确切类型</li></ul><h5 id="_7-数组元素的比较" tabindex="-1"><a class="header-anchor" href="#_7-数组元素的比较" aria-hidden="true">#</a> 7.数组元素的比较</h5><p>程序设计是为了 “将保持不变的事物与会发生改变的事物相分离” （策略设计模式）</p><p>有两种方式来提供比较功能</p><ul><li><p>实现<code>Java.lang.Comparable</code>接口，实现<code>CompareTo()</code>方法，使当前类具有比较功能</p><p><code>Arrays.sort()</code></p></li><li><p>实现<code>Comparator</code>接口，实现<code>Compare()</code>方法成为一个比较器</p><p><code>Collections.reverseOrder()</code> 会产生一个<code>Comparator</code></p></li></ul><p>总结：</p><p>随着<code>Java</code>版本的更新，对容器的支持得到了明显的改进，并且现在的容器除了性能之外的各个方面都使得数组相形见绌。</p><p>有了自动包装机制和泛型，在容器中持有基本类型就变得易如反掌了，并且泛型的出现时对数组极大的威胁，所以除了（切换到数组对性能有所帮助）时，你才应该使用数组进行重构，否则应该使用容器。</p>',18),h=[c];function l(i,n){return a(),o("div",null,h)}const s=e(r,[["render",l],["__file","shuzu.html.vue"]]);export{s as default};
