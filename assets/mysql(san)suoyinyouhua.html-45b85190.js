import{_ as e,o as a,c as o,b as r}from"./app-8a583c06.js";const t={},p=r('<blockquote><p>索引优化的目的主要是让索引不失效</p></blockquote><h5 id="_1、最佳左前缀法则" tabindex="-1"><a class="header-anchor" href="#_1、最佳左前缀法则" aria-hidden="true">#</a> 1、最佳左前缀法则</h5><blockquote><p>在创建了多列索引的情况下，查询从索引的 <strong>最左前列开始且不能跳过索引中的列</strong>。</p><p>最佳左前缀法则就是说如果创建了多个索引，在使用索引时要按照创建索引的顺序来使用，不能缺少或跳过。（如果使用跳过开头则索引失效、如果跳过中间则后面索引失效）</p><p>通俗理解：“带头大哥不能死，中间兄弟不能断”。要点：“头不能掉”。</p></blockquote><h5 id="_2、不要在索引列上做任何操作" tabindex="-1"><a class="header-anchor" href="#_2、不要在索引列上做任何操作" aria-hidden="true">#</a> 2、不要在索引列上做任何操作</h5><blockquote><p>在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效从而转向全表扫描。</p></blockquote><h5 id="_3、范围右边索引列全失效" tabindex="-1"><a class="header-anchor" href="#_3、范围右边索引列全失效" aria-hidden="true">#</a> 3、范围右边索引列全失效</h5><blockquote><p>存储引擎不能使用索引中范围右边的列</p><p>当使用 age &gt; 27 这种范围时，会导致范围右边的索引列失效</p></blockquote><h5 id="_4、尽量使用覆盖索引" tabindex="-1"><a class="header-anchor" href="#_4、尽量使用覆盖索引" aria-hidden="true">#</a> 4、尽量使用覆盖索引</h5><blockquote><p>尽量使用覆盖索引（查询列和索引列尽量一致，通俗说就是对A、B列创建了索引，然后查询中也使用A、B列），减少select *的使用。</p><p>explain执行计划显示：Extra从Null变成了Using index，提高检索效率。</p></blockquote><h5 id="_5、使用不等于-或-会使type-range" tabindex="-1"><a class="header-anchor" href="#_5、使用不等于-或-会使type-range" aria-hidden="true">#</a> 5、使用不等于（!= 或 &lt;&gt;）会使Type = range</h5><blockquote><p>使用 != 会使type=range，Extra Using index condition</p></blockquote><h5 id="_6、is-null-或-is-not-null-也无法使用索引" tabindex="-1"><a class="header-anchor" href="#_6、is-null-或-is-not-null-也无法使用索引" aria-hidden="true">#</a> 6、is null 或 is not null 也无法使用索引</h5><blockquote><p>在使用is null的时候，索引完全失效，使用is not null的时候，type=ALL全表扫描，key=Null索引失效。</p></blockquote><h5 id="_7、like通配符以-开头会使索引失效" tabindex="-1"><a class="header-anchor" href="#_7、like通配符以-开头会使索引失效" aria-hidden="true">#</a> 7、like通配符以 % 开头会使索引失效</h5><blockquote><p>like的%位置不同，所产生的效果不一样，当%出现在左边的时候，type=ALL，key=Null（全表扫描，索引失效），当%出现在右边的时候，type=range，索引未失效。</p><p>口诀：like百分加右边。</p><p>但是在实际生产环境中，%仅出现在右边可能不能够解决我们的问题，所以解决%出现在左边索引失效的方法：使用覆盖索引。</p></blockquote><h5 id="_8、字符串不加单引号导致索引失效" tabindex="-1"><a class="header-anchor" href="#_8、字符串不加单引号导致索引失效" aria-hidden="true">#</a> 8、字符串不加单引号导致索引失效</h5><blockquote><p>varchar类型的字段，在查询的时候不加单引号(进行了类型转换)导致索引失效，转向全表扫描。</p></blockquote><h5 id="_9、少用or-用or连接会使type-range" tabindex="-1"><a class="header-anchor" href="#_9、少用or-用or连接会使type-range" aria-hidden="true">#</a> 9、少用or，用or连接会使Type = range</h5><blockquote><p>在使用or连接的时候会使type = range、Extra = Using where; Using index</p></blockquote><h4 id="索引分析结论" tabindex="-1"><a class="header-anchor" href="#索引分析结论" aria-hidden="true">#</a> 索引分析结论</h4><p>case 1、</p><blockquote><p>在执行常量等值查询时，改变索引列的顺序并不会更改explain的执行结果，因为mysql底层优化器会进行优化，但是推荐按照索引顺序列编写sql语句。</p></blockquote><p>case 2、</p><blockquote><p>范围右边索引列失效，但是范围当前位置的索引是有效的</p><p>范围右边索引列失效，是有顺序的：c1,c2,c3,c4，如果c3有范围，则c4失效；如果c4有范围，则没有失效的索引列，从而会使用全部索引。</p><p>如果在c1处使用范围，则type=ALL，key=Null，索引失效，全表扫描，这里违背了最佳左前缀法则，带头大哥已死，因为c1主要用于范围，而不是查询。解决方式使用覆盖索引。</p><p>结论：在最佳左前缀法则中，如果最左前列（带头大哥）的索引失效，则后面的索引都失效。</p></blockquote><p>总结：</p><p>①最佳左前缀法则。</p><p>1.在等值查询时，更改索引列顺序，并不会影响explain的执行结果，因为mysql底层会进行优化。</p><p>2.在使用order by时，注意索引顺序、常量，以及可能会导致Using filesort的情况。</p><p>②group by容易产生Using temporary。</p><p>③通俗理解口诀：</p><p>全值匹配我最爱，最左前缀要遵守；</p><p>带头大哥不能死，中间兄弟不能断；</p><p>索引列上少计算，范围之后全失效；</p><p>LIKE百分写最右，覆盖索引不写星；</p><p>不等空值还有or，索引失效要少用。</p>',35),n=[p];function l(i,c){return a(),o("div",null,n)}const s=e(t,[["render",l],["__file","mysql(san)suoyinyouhua.html.vue"]]);export{s as default};
