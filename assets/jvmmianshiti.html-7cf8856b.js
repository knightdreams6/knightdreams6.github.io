import{_ as o,o as e,c as d,b as c}from"./app-5f8194d9.js";const r={},a=c('<h4 id="_1、请谈谈你对jvm的理解" tabindex="-1"><a class="header-anchor" href="#_1、请谈谈你对jvm的理解" aria-hidden="true">#</a> 1、请谈谈你对<code>JVM</code>的理解？</h4><blockquote><p><code>Java</code>语言的一个非常重要的特点就是与平台无关性。而使用 <code>JVM</code> 是实现这一特点的关键。<code>Java</code>语言编写的源程序通过编译器，就编译成了与平台无关的字节码文件，然后便可以在<code>JVM</code>上运行</p></blockquote><h4 id="_2、java8的虚拟机有什么更新" tabindex="-1"><a class="header-anchor" href="#_2、java8的虚拟机有什么更新" aria-hidden="true">#</a> 2、<code>java8</code>的虚拟机有什么更新？</h4><blockquote><p>在<code>java8</code>中，永久代已经被移除，被一个名为 <strong>元空间</strong> 的区域所取代。元空间的本质和永久代类似。</p></blockquote><h5 id="元空间和永久代的最大区别" tabindex="-1"><a class="header-anchor" href="#元空间和永久代的最大区别" aria-hidden="true">#</a> 元空间和永久代的最大区别？</h5><blockquote><p>永久代使用的是 <code>JVM</code> 的堆内存，但是元空间 <strong>不在虚拟机中而是使用的本机物理内存</strong></p><p>因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入本地内存，字符串池和类的静态变量放入堆中，这样可以加载多少类的元数据不再有 <code>MaxPermSize</code> 控制，而由系统实际可用空间来控制</p></blockquote><h4 id="_3、jvm的常用参数调优有哪些" tabindex="-1"><a class="header-anchor" href="#_3、jvm的常用参数调优有哪些" aria-hidden="true">#</a> 3、<code>JVM</code>的常用参数调优有哪些？</h4><p>堆内存调优简介</p><p><code>-Xms</code> 初始分配大小，默认为物理内存的 1/64</p><p><code>-Xmx</code> 最大分配内存，默认为物理内存的 1/4</p><blockquote><p>生产环境中一般将初始分配大小和最大分配内存一样大，避免<code>GC</code>和其它程序争抢内存</p></blockquote><p><code>-XX:+PrintGCDetails</code> 输出详细的<code>GC</code>处理细节</p><p><code>-XX:MaxTenuringThreshold</code> 设置对象在新生代中存活的次数，到达该次数对象就会进入老年代（<code>Java8</code>中不能超过15，缺省值为15）</p><h4 id="_4、gc" tabindex="-1"><a class="header-anchor" href="#_4、gc" aria-hidden="true">#</a> 4、<code>GC</code></h4><p><code>GC(Garbage Collection)</code> 是垃圾回收的意思，因为<code>java</code>是动态分配内存大小的，并且依靠垃圾回收机制来完成对分配空间的回收，从而避免内存溢出的问题。</p><p><code>GC</code>一般都采用<strong>分代回收算法</strong>。</p><blockquote><p><code>JVM</code> 在进行 <code>GC</code>时，并非每次都对 young，Old，Perm三个内存区域一起回收，大部分回收的是新生代</p><p>因此<code>GC</code>按照回收的区域又分成了两种类型，一种是普通<code>GC</code>（<code>minor GC</code>）,一种是全局<code>GC</code>(<code>major GC or Full GC</code>)</p></blockquote><h5 id="minor-gc和-full-gc的区别" tabindex="-1"><a class="header-anchor" href="#minor-gc和-full-gc的区别" aria-hidden="true">#</a> <code>Minor GC</code>和 <code>Full GC</code>的区别</h5><p><code>minor GC</code>：只针对新生代区域，指发生在新生代的垃圾收集动作，因为<code>java</code>对象存活率都不高，所以<code>minor GC</code>费用频繁，一般回收速度也快</p><p><code>major GC</code>：指发生在老年代的垃圾收集动作，出现了 <code>major GC</code>，经常会伴随至少一次的 <code>minor GC</code>(但并不是绝对的)。<code>major GC</code>一般比<code>minor GC</code>速度慢十倍以上（<code>major GC</code>空间大）。</p><h5 id="_4算法" tabindex="-1"><a class="header-anchor" href="#_4算法" aria-hidden="true">#</a> 4算法</h5><ol><li><p>引用计数法（不使用）</p><p>缺点：</p><ul><li>每次对对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗</li><li>较难处理循环引用</li></ul></li><li><p>复制算法（Copying）</p><p>常见常用方法， <strong>年轻代</strong>中使用的是 <code>Minor GC</code>，这种<code>GC</code>算法采用的是复制算法 ,复制算法的基本思想是将内存分为两块，每次只用其中一块，当一块内存用完，就将还活着的对象复制到另外一块上面。</p><p><strong>复制算法不会产生内存碎片</strong>。<strong>缺点：耗空间</strong></p><p>原理：</p><ul><li>从根集合开始，通过Tracing从From中找到存活对象，拷贝到To中</li><li>From、To交换身份，下次内存分配从To开始</li></ul></li><li><p>标记清除（Mark - Sweep）</p><p><strong>老年代</strong>一般是由标记清除或者是标记清除与标记整理的混合</p><p>算法分为标记和清除两个阶段，<strong>先标记出要回收的对象，然后统一回收这些对象</strong>。</p><p>通俗的讲：当程序运行期间，若可以使用的内存被耗尽的时候，<code>GC</code> 线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最后统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。</p><p>缺点：</p><ul><li>两次扫描，耗时严重</li><li>会产生<strong>内存碎片</strong>（空间内存不连续）</li></ul></li><li><p>标记压缩（Mark-Compact）</p><p>原理：</p><ol><li><p>标记</p><p>与 <strong>标记-清除</strong>一样</p></li><li><p>压缩</p><p>再次扫描，并往一端 <strong>滑动</strong>存活对象</p></li></ol><p>标记/整理算法的唯一缺点就是 <strong>效率不高</strong>，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。</p><p>从效率上来说，标记/整理算法低于复制算法。</p></li></ol><h5 id="三种算法的比较" tabindex="-1"><a class="header-anchor" href="#三种算法的比较" aria-hidden="true">#</a> 三种算法的比较</h5><p>内存效率：复制算法 &gt; 标记清除算法 &gt; 标记整理算法 （此处的效率只是简单的对比时间复杂度）</p><p>内存整齐度：复制算法 = 标记整理算法 &gt; 标记清除算法</p><p>内存利用率：标记整理算法 = 标记清除算法 &gt; 复制算法</p><h4 id="_5、minorgc-的过程-复制-··-清空-··-交换" tabindex="-1"><a class="header-anchor" href="#_5、minorgc-的过程-复制-··-清空-··-交换" aria-hidden="true">#</a> 5、<code>MinorGC</code> 的过程 （复制 ··&gt; 清空 ··&gt; 交换）</h4><p><strong>1. <code>eden</code>、<code>SurvivorForm</code>复制到<code>SurvivorTo</code>，年龄加1</strong></p><blockquote><p>首先，当Eden区满的时候会触发第一次<code>GC</code>，把还活着的对象拷贝到<code>SurvivorForm</code>区，当Eden区再次触发<code>GC</code>时会对 Eden + <code>survivorForm</code>区进行垃圾回收，经过这次回收还存活的对象，则直接复制到 To区（如果有对象达到老年区的标准，则复制到老年代区），同时把这些对象的年龄+1</p></blockquote><p><strong>2. 清空<code>eden</code>、<code>SurvivorForm</code></strong></p><blockquote><p>进行<code>GC</code>的时候回清空<code> eden</code>、<code>survivorForm</code>区中的对象</p></blockquote><p><strong>3. <code>SurvivorForm</code> 和 <code>SurvivorTo</code>互换</strong></p><blockquote><p>最后 <code>survivorForm</code>区和 <code>survivorTo</code>区互换，原来的 to区成为下一次<code>GC</code>时的form区。部分对象会在 form和to 区域中复制来复制去，如此交换15次（由<code>JVM</code>参数<code>MaxTenuringThreshold</code>决定，默认值为15），最终如果还是存活就存入老年代</p></blockquote><h4 id="_6、什么是类装载器classloader" tabindex="-1"><a class="header-anchor" href="#_6、什么是类装载器classloader" aria-hidden="true">#</a> 6、什么是类装载器<code>ClassLoader</code>？</h4><blockquote><p>负责加载class文件，class文件在 <strong>文件开头有特定的文件标识</strong> 将class文件字节码内容加载到内存中，并将这些内容转换成方法区中运行时数据结构。类装载器只负责class文件的加载，至于它是否可以运行，则有执行引擎决定</p></blockquote><p><strong>虚拟机自带的加载器</strong></p><ul><li>启动类加载器（Bootstrap）</li><li>扩展类加载器（Extension）</li><li>应用程序类加载器（<code>AppClassLoader</code>） <ul><li>用来加载当前应用的 <code>classpath</code> 下的所有类</li></ul></li></ul><p><strong>用户自定义加载器</strong></p><p><code>java.lang.ClassLoader</code> 的子类，用户可以定制类的加载方式</p><h5 id="什么是双亲委派机制-、" tabindex="-1"><a class="header-anchor" href="#什么是双亲委派机制-、" aria-hidden="true">#</a> 什么是双亲委派机制？、</h5><p>当一个类收到了类加载请求，它首先不会尝试自己其加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器在它的加载路径下没有找到所需加载的Class，子类加载器才会去尝试自己去加载。</p><p>采用双亲委派的一个好处是，不管使用哪个加载器加载类，最终都会委托给顶层的启动类加载器进行加载，保证了沙箱安全</p>',42),i=[a];function n(t,l){return e(),d("div",null,i)}const s=o(r,[["render",n],["__file","jvmmianshiti.html.vue"]]);export{s as default};
