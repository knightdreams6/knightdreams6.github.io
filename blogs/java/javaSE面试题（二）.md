---
title: javaSE面试题(二)
date: 2019-12-15 10:04:38
tags: 
  - java
---

#### 1、简述线程、程序、进程的基本概念

**线程**与进程类似，是一个比继承更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间切换工作时，负担要比进程小的多，也正因为如此，线程也被称为轻量级进程

**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。

**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建、运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。线程是进程划分成的更小的运行单位。

**线程和进程的最大区别**在于基本上各进程是独立的，而各线程不一定，因为同一进程中的线程既有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。

---

#### 2、线程有哪些基本状态？

Java线程在运行的生命周期中的指定时刻只可能存在下面6中不同状态的其中一个状态

| 状态名称     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NEW          | 初始状态，线程被构建，但是还没有调用start()方法              |
| RUNNABLE     | 运行状态，Java线程将操作系统中的就绪和运行两种状态统称为“运行中” |
| BLOCKED      | 阻塞状态，表示线程阻塞于锁                                   |
| WAITING      | 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其它线程做出一些特定的动作（通知或中断） |
| TIME_WAITING | 超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的 |
| TERMINATED   | 终止状态，表示当前线程已经执行完毕                           |

![](https://s2.ax1x.com/2019/12/15/QW4MTg.png)

由上图可以看出：

线程创建之后它将处于 **NEW（新建）** 状态，调用 `start()` 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 **RUNNING（运行）** 状态。

> 操作系统隐藏 Java虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：[HowToDoInJava](https://howtodoinjava.com/)：[Java Thread Life Cycle and Thread States](https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/)），所以 Java 系统一般将这两个状态统称为 **RUNNABLE（运行中）** 状态 。

当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）**状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 **TIME_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 **BLOCKED（阻塞）** 状态。线程在执行 Runnable 的`run()`方法之后将会进入到 **TERMINATED（终止）** 状态。

---

#### 3、final关键字

final关键字主要用在三个地方：变量、方法、类。

1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化后便不能随便更改；如果是引用变量，则初始化后便不能让其指向另一个对象
2. final修饰一个类，表明这个类不能被继承。final类的所有成员方法都会隐式地指定为final方法
3. 使用final的原因有两个
   * 把方法锁定，以防止任何继承类修改它的含义，类中所有private方法都会被隐式地指定为final
   * 效率（不考虑）

---

#### 4、Java序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用`transient`关键字修饰。

transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。

---

#### 5、Java中的IO流

**Java中的IO流分为几种？**

* 按流的流向分，可以分为输入流和输出流
* 按操作单元划分，可以划分为字节流和字符流
* 按照流的角色划分可以分为节点流和处理流

**Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。**

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。



**按操作方式分类结构图：**

![](https://s2.ax1x.com/2019/12/15/QW5n3R.jpg)



**按操作对象分类结构图**

![](https://s2.ax1x.com/2019/12/15/QW5J4H.jpg)

##### **既然有了字节流，为什么还要有字符流？**

问题本质：**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那么为什么还要区分字符/字节流操作**

> 答：字符流是Java虚拟机将字节流转换得到的，这个过程非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以I/O就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。比如音频、文件、图片等媒体文件用字节流比较好，而涉及到字符的话使用字符流比较好



##### BIO\NIO\AIO区别

* BIO（Blocking I/O）:同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的,不用考虑系统过载、限流等问题。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
* NIO（New I/O）:NIO是一种同步非阻塞I/O模式，Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发

* **AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。
