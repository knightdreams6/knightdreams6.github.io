---
title: 数组
date: 2020-04-30 09:47:14
tags:
  - java
---

### 数组

##### 1.数组是一种效率最高的存储和随机访问对象引用序列的方式，(这种高效是通过固定长度换来的)【数组是简单的线性序列】

##### 2.数组可以持有基本类型，而泛型之前的容器不行，但有了泛型，容器可以指定并检查它们所持有的对象类型【看起来可以持有基本类型】。对象数组保存的是引用，基本类型数组直接保存基本类型的值

##### 3.无论使用哪种类型的数组，数组标识符只是一个引用，指向在堆中建立一个真实的对象，这个(数组)对象用以保存其他对象的引用。只读成员length是该对象的一部分(唯一一个可以访问的字段或方法)

##### 4. length是数组的大小，而不是实际保存的元素个数，新生成一个数组对象，其中所有的引用会被自动初始化为null，基本类型自动初始化为0，字符类型自动初始化为char(O)，boolean类型自动初始化为false

##### 5.工具类Arrays方法

> `equals() `			`deepEquals()`用于比较多维数组
>
> `fill()` 填充数组		`binarySearch()` 对已排序数组进行查询
>
> `toString()`			`hashCode()`		`asList()`将数组转化为List

##### 6.数组的复制

`system.arraycopy()` 该方法比for循环复制快很多

所需参数(源数组，源数组从什么位置开始，目标数组，从目标数组什么位置开始复制，需要复制的元素个数)

* 复制对象时只复制了对象的引用“浅拷贝”
* 不会自动执行自动包装和拆包，两个对对象必须有相同的确切类型

##### 7.数组元素的比较

程序设计是为了 “将保持不变的事物与会发生改变的事物相分离”  （策略设计模式）

有两种方式来提供比较功能

* 实现`Java.lang.Comparable`接口，实现`CompareTo()`方法，使当前类具有比较功能

  `Arrays.sort()`

* 实现`Comparator`接口，实现`Compare()`方法成为一个比较器

  `Collections.reverseOrder()` 会产生一个`Comparator`

总结：

随着`Java`版本的更新，对容器的支持得到了明显的改进，并且现在的容器除了性能之外的各个方面都使得数组相形见绌。

有了自动包装机制和泛型，在容器中持有基本类型就变得易如反掌了，并且泛型的出现时对数组极大的威胁，所以除了（切换到数组对性能有所帮助）时，你才应该使用数组进行重构，否则应该使用容器。
